#!/usr/bin/env expect

set con_prompt "(ns: getty) linuxkit-*:*# "
set ssh_prompt "linuxkit-*:*# "
set timeout 120

proc kill args {
    foreach what $args {
        global $what
        if [info exists $what] {
            upvar #0 $what sid
            set pid [exp_pid -i $sid]
            puts "killing $what ($sid) = $pid"
            exec kill $pid
            close $sid
        } else {
            puts "not killing $what (not started)"
        }
    }
}

proc boot_linuxkit {} {
    global lk_sid
    # "medium" level circle CI has 4G of RAM, use 3.5G for VM
    # small               1.0     2GB
    # medium (default)    2.0     4GB     (3584M)
    # medium+             3.0     6GB
    # large               4.0     8GB     (7680M)
    # xlarge              8.0     16GB    (15827M)
    spawn env {KUBE_RUN_ARGS=-publish 2222:22} KUBE_MEM=15872 KUBE_VCPUS=8 KUBE_DISK=8G KUBE_CLEAR_STATE=y KUBE_MASTER_UNTAINT=y ./boot.sh
    set lk_sid $spawn_id
    puts "INFO lk ($lk_sid) is pid [exp_pid -i $lk_sid]"
}

proc ssh_into_kubelet {} {
    global ssh_sid

    set sshopts {-p 2222 -o ConnectTimeout=5 -o LogLevel=DEBUG}
    if [info exists ::env(SSHOPTS)] {
        set sshopts [concat $::env(SSHOPTS) $sshopts]
    }
    spawn env SSHOPTS=$sshopts ./ssh_into_kubelet.sh localhost
    set ssh_sid $spawn_id
    puts "INFO ssh ($ssh_sid) is pid [exp_pid -i $ssh_sid]"
}

proc await_prompt {sidvar promptvar step} {
    upvar #0 $sidvar sid $promptvar prompt
    expect -i $sid \
        $prompt {
            puts "SUCCESS $step"
        } timeout {
            puts "FAIL $step (timeout)"
            kill ssh_sid lk_sid
            exit 1
        } eof {
            puts "FAIL $step (eof)"
            kill ssh_sid lk_sid
            exit 1
        }
}

proc send_con {s} {
    global lk_sid
    send -i $lk_sid $s
}

proc await_con_prompt {step} {
    global lk_sid con_prompt
    await_prompt lk_sid con_prompt $step
}

proc send_ssh {s} {
    global ssh_sid
    send -i $ssh_sid $s
}

proc await_ssh_prompt {step} {
    global ssh_sid ssh_prompt
    await_prompt ssh_sid ssh_prompt $step
}

boot_linuxkit

await_con_prompt "boot"

send_con "ifconfig eth0\n"
await_con_prompt "ifconfig"

send_con "ctr container ls\n"
await_con_prompt "ctr container ls"

send_con "ctr task ls\n"
# This was added in a debug attempt, but it turned out sshd was failing to come up (which this didn't help us to discover), so not much use now.
#set retries 0
#expect -i lk_sid -timeout 300 \
#    "sshd * RUNNING" {
#        puts "SUCCESS sshd running"
#    } $con_prompt {
#        set retries [expr $retries + 1]
#        puts "RETRY:$retries await sshd"
#        sleep 1
#        send_con "ctr task ls\n"
#        exp_continue -continue_timer
#    } timeout {
#        puts "FAIL sshd (timeout)"
#        kill ssh_sid lk_sid
#    }
#await_con_prompt "post sshd startup (after $retries attempts)"

set retries 0
ssh_into_kubelet
# provide ssh_sid as an indirect, allowing ssh to be respawned, which
# changes the id, we need this in case ssh cannot immediately connect.
expect -i ssh_sid \
    $ssh_prompt {
        puts "SUCCESS connected to ssh (after $retries attempts)"
    } "read: Connection reset by peer" {
        # ssh happened too soon, wait a bit.
        set retries [expr $retries + 1]
        puts "RETRY:$retries ssh (conn reset)"
        wait -i $ssh_sid
        sleep 1
        ssh_into_kubelet
        exp_continue -continue_timer
    } eof {
        set retries [expr $retries + 1]
        puts "RETRY:$retries ssh (eof)"
        wait -i $ssh_sid
        sleep 1
        ssh_into_kubelet
        exp_continue -continue_timer
    } timeout {
        puts "FAIL ssh (timeout)"
        kill ssh_sid lk_sid
        exit 1
    }

puts "RUN kubeadm-init.sh"
send_ssh "kubeadm-init.sh\n"

# Written as N*5m with logging to avoid "10 mins with no output" from CI
set retries 0
set maxretries 10
expect -i $ssh_sid -timeout 300 \
    "Your Kubernetes master has initialized successfully!" {
        puts "SUCCESS cluster initialised!"
    } $ssh_prompt {
        puts "FAIL kubeadm-init.sh (returned to prompt)"
        kill ssh_sid lk_sid
        exit 1
    } timeout {
        set retries [expr $retries + 1]
        if [expr $retries < $maxretries] {
            puts "RETRY:$retries kubeadm-init.sh (timeout)"
            exp_continue
        }
        puts "FAIL kubeadm-init.sh (timeout)"
        kill ssh_sid lk_sid
        exit 1
    } eof {
        puts "FAIL kubeadm-init.sh (eof)"
        kill ssh_sid lk_sid
        exit 1
    }
await_ssh_prompt "kubeadm-init.sh"
puts "SUCCESS kubeadm-init complete"

send_ssh "kubectl get nodes\n"
set retries 0
expect -i lk_sid -timeout 300 \
    "linuxkit-* Ready" {
        puts "SUCCESS node ready"
    } $ssh_prompt {
        set retries [expr $retries + 1]
        puts "RETRY:$retries await node ready"
        sleep 1
        send_con "kubectl get nodes\n"
        exp_continue -continue_timer
    } timeout {
        puts "FAIL node ready (timeout)"
        kill ssh_sid lk_sid
    }
await_ssh_prompt "post await node ready (after $retries attempts)"

kill ssh_sid

puts "RUN poweroff -f"
send_con "poweroff -f\n"

expect -i $lk_sid \
    "Power down" {
        puts "SUCCESS poweroff"
    } eof {
        puts "SUCCESS poweroff"
    } timeout {
        puts "FAILED poweroff (timeout)"
        exit 1
    }
